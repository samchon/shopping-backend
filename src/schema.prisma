datasource db {
    provider = "postgresql"
    url      = env("POSTGRESQL_URL")
}

generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["views"]
}

generator markdown {
    provider = "prisma-markdown"
    title    = "Shopping Mall"
    output   = "../docs/ERD.md"
}

//-----------------------------------------------------------
// ARTICLES
//-----------------------------------------------------------
/// Attachment File.
///
/// Every attachment files that are managed in this shopping mall system.
///
/// For reference, it is possible to omit one of file name or extension like 
/// `.gitignore` or `README` case, but not possible to omit both of them,
///
/// @namespace Articles
/// @author Samchon
model attachment_files {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// File name, except extension.
    ///
    /// Possible to omit like `.gitignore` case.
    ///
    /// @minLength 1
    /// @maxLength 255
    name String? @db.VarChar

    /// Extension.
    ///
    /// Possible to omit like `README` case.
    ///
    /// @minLength 1
    /// @maxLength 8
    extension String? @db.VarChar

    /// URL path of the real file.
    ///
    /// @format url
    url String @db.VarChar

    //----
    // RELATIONS
    //----
    bbs_article_snapshot_files          bbs_article_snapshot_files[]
    bbs_article_comment_snapshots_files bbs_article_comment_snapshot_files[]
}

/// Article entity.
/// 
/// `bbs_articles` is a super-type entity of all kinds of articles in the 
/// current shopping mall system, literally shaping individual articles of 
/// the bulletin board.
///
/// And, as you can see, the elements that must inevitably exist in the 
/// article, such as the title or the body, do not exist in the `bbs_articles`, 
/// but exist in the subsidiary entity, {@link bbs_article_snapshots}, as a 
/// 1: N relationship, which is because a new snapshot record is published 
/// every time the article is modified.
///
/// The reason why a new snapshot record is published every time the article 
/// is modified is to preserve the evidence. Due to the nature of e-commerce, 
/// there is always a threat of dispute among the participants. And it can 
/// happen that disputes arise through articles or comments, and to prevent 
/// such things as modifying existing articles to manipulate the situation, 
/// the article is designed in this structure.
///
/// In other words, to keep evidence, and prevent fraud.
///
/// @namespace Articles
/// @erd Inquiries
/// @author Samchon
model bbs_articles {
    /// @format uuid
    id String @id @db.Uuid

    /// Creation time of article.
    created_at DateTime @db.Timestamptz

    /// Deletion time of article.
    ///
    /// To keep evidence, do not delete the article, but just mark it as 
    /// deleted.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// List of snapshots.
    ///
    /// It is created for the first time when an article is created, and is
    /// accumulated every time the article is modified.
    ///
    /// @minItems 1
    snapshots bbs_article_snapshots[]

    /// List of comments.
    comments                               bbs_article_comments[]
    shopping_sale_snapshot_inquiries       shopping_sale_snapshot_inquiries[]
    shopping_sale_snapshot_inquiry_answers shopping_sale_snapshot_inquiry_answers[]

    @@index([created_at])
}

/// Snapshot of article.
///
/// `bbs_article_snapshots` is a snapshot entity that contains the contents of
/// the article, as mentioned in {@link bbs_articles}, the contents of the 
/// article are separated from the article record to keep evidence and prevent 
/// fraud.
///
/// @namespace Articles
/// @erd Inquiries
/// @author Samchon
model bbs_article_snapshots {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belong article's {@link bbs_articles.id}
    ///
    /// @format uuid
    bbs_article_id String @db.Uuid

    /// Format of body.
    ///
    /// Same meaning with extension like `html`, `md`, `txt`.
    format String @db.VarChar

    /// Title of article.
    title String @db.VarChar

    /// Content body of article.
    body String

    /// Creation time of record.
    ///
    /// It means creation time or update time or article.
    created_at DateTime @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belong article info.
    article bbs_articles @relation(fields: [bbs_article_id], references: [id], onDelete: Cascade)

    /// List of wrappers of attachment files.
    to_files                                bbs_article_snapshot_files[]
    shopping_sale_snapshot_review_snapshots shopping_sale_snapshot_review_snapshots[]

    @@index([bbs_article_id, created_at])
}

/// Attachment file of article snapshot.
///
/// `bbs_article_snapshot_files` is an entity that shapes the attached files of
/// the article snapshot.
///
/// `bbs_article_snapshot_files` is a typical pair relationship table to 
/// resolve the M: N relationship between {@link bbs_article_snapshots} and
/// {@link attachment_files} tables. Also, to ensure the order of the attached
/// files, it has an additional `sequence` attribute, which we will continue to
/// see in this documents.
///
/// @namespace Articles
/// @author Samchon
model bbs_article_snapshot_files {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged snapshot's {@link bbs_article_snapshots.id}
    ///
    /// @format uuid
    bbs_article_snapshot_id String @db.Uuid

    /// Belonged file's {@link attachment_files.id}
    ///
    /// @format uuid
    attachment_file_id String @db.Uuid

    /// Sequence of attachment file in the snapshot.
    ///
    /// @format int
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    /// Belonged article.
    snapshot bbs_article_snapshots @relation(fields: [bbs_article_snapshot_id], references: [id], onDelete: Cascade)

    /// Belonged file.
    file attachment_files @relation(fields: [attachment_file_id], references: [id], onDelete: Cascade)

    @@index([bbs_article_snapshot_id])
    @@index([attachment_file_id])
}

/// Comment written on an article.
///
/// `bbs_article_comments` is an entity that shapes the comments written on an
/// article.
///
/// And for this comment, as in the previous relationship between 
/// {@link bbs_articles} and {@link bbs_article_snapshots}, the content body 
/// of the comment is stored in the sub {@link bbs_article_comment_snapshots} 
/// table for evidentialism, and a new snapshot record is issued every time 
/// the comment is modified.
///
/// Also, `bbs_article_comments} is expressing the relationship of the 
/// hierarchical reply structure through the `parent_id` attribute.
///
/// @namespace Articles
/// @erd Inquiries
/// @author Samchon
model bbs_article_comments {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged article's {@link bbs_articles.id}
    /// 
    /// @format uuid
    bbs_article_id String @db.Uuid

    /// Parent comment's {@link bbs_article_comments.id}
    ///
    /// Used to express the hierarchical reply structure.
    ///
    /// @format uuid
    parent_id String? @db.Uuid

    /// Creation time of comment.
    created_at DateTime @db.Timestamptz

    /// Deletion time of comment.
    ///
    /// Do not allow to delete the comment, but just mark it as deleted, 
    /// to keep evidence.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged article.
    article bbs_articles @relation(fields: [bbs_article_id], references: [id], onDelete: Cascade)

    /// Parent comment.
    ///
    /// Only when reply case.
    parent bbs_article_comments? @relation("bbs_article_comments_reply", fields: [parent_id], references: [id], onDelete: Cascade)

    /// List of children comments.
    ///
    /// Reply comments of current.
    children bbs_article_comments[] @relation("bbs_article_comments_reply")

    /// List of snapshots.
    ///
    /// It is created for the first time when a comment is created, and is
    /// accumulated every time the comment is modified.
    ///
    /// @minItems 1
    snapshots                               bbs_article_comment_snapshots[]
    shopping_sale_snapshot_inquiry_comments shopping_sale_snapshot_inquiry_comments[]

    @@index([bbs_article_id, parent_id, created_at])
}

/// Snapshot of comment.
///
/// `bbs_article_comment_snapshots` is a snapshot entity that contains the 
/// contents of the comment.
///
/// As mentioned in {@link bbs_article_comments}, designed to keep evidence 
/// and prevent fraud.
///
/// @namespace Articles
/// @author Samchon
model bbs_article_comment_snapshots {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged article's {@link bbs_article_comments.id}
    ///
    /// @format uuid
    bbs_article_comment_id String @db.Uuid

    /// Format of content body.
    ///
    /// Same meaning with extension like `html`, `md`, `txt`.
    format String @db.VarChar

    /// Content body of comment.
    body String

    /// Creation time of record.
    ///
    /// It means creation time or update time or comment.
    created_at DateTime @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belong comment info.
    comment bbs_article_comments @relation(fields: [bbs_article_comment_id], references: [id], onDelete: Cascade)

    /// List of wrappers of attachment files.
    files bbs_article_comment_snapshot_files[]

    @@index([bbs_article_comment_id, created_at])
}

/// Attachment file of comment snapshot.
/// 
/// `bbs_article_comment_snapshot_files` is an entity resolving the M:N 
/// relationship between {@link bbs_article_comment_snapshots} and 
/// {@link attachment_files} tables.
/// 
/// @namespace Articles
/// @author Samchon
model bbs_article_comment_snapshot_files {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged snapshot's {@link bbs_article_comment_snapshots.id}
    ///
    /// @format uuid
    bbs_article_comment_snapshot_id String @db.Uuid

    /// Belonged file's {@link attachment_files.id}
    ///
    /// @format uuid
    attachment_file_id String @db.Uuid

    /// Sequence order.
    ///
    /// Sequence order of the attached file in the belonged snapshot.
    ///
    /// @type int
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    /// Belonged article.
    snapshot bbs_article_comment_snapshots @relation(fields: [bbs_article_comment_snapshot_id], references: [id], onDelete: Cascade)

    /// Belonged file.
    file attachment_files @relation(fields: [attachment_file_id], references: [id], onDelete: Cascade)

    @@index([bbs_article_comment_snapshot_id])
    @@index([attachment_file_id])
}

//-----------------------------------------------------------
// SYSTEMATIC
//-----------------------------------------------------------
/// Channel information.
///
/// `shopping_channels` is a concept that shapes the distribution channel in 
/// the market. Therefore, the difference in the channel in this e-commerce 
/// system means that it is another site or application.
///
/// By the way, if your shopping mall system requires only one channel, then 
/// just use only one. This concept is designed to be expandable in the future.
///
/// @namespace Systematic
/// @erd Sales
/// @author Samchon
model shopping_channels {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Identifier code.
    code String @db.VarChar

    /// Name of channel.
    name String @db.VarChar

    /// Whether the channel is exclusive.
    ///
    /// If this value is `true`, the channel is disconnected from other 
    /// channels and does not share customer information.
    exclusive Boolean @db.Boolean

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Update time of record.
    updated_at DateTime @db.Timestamptz

    /// Deletion time of record.
    deleted_at                        DateTime?                           @db.Timestamptz
    shopping_channel_categories       shopping_channel_categories[]
    shopping_customers                shopping_customers[]
    shopping_citizens                 shopping_citizens[]
    shopping_members                  shopping_members[]
    shopping_member_emails            shopping_member_emails[]
    shopping_sale_snapshot_channels   shopping_sale_snapshot_channels[]
    shopping_coupon_channel_criterias shopping_coupon_channel_criterias[]

    //----
    // RELATIONS
    //----
    @@unique([code])
    @@unique([name])
}

/// Category of channel.
///
/// ` is a concept that refers to classification categories within a specific 
/// channel, and is exactly the same as the concept commonly referred to as 
/// "category" in shopping malls.
///
/// And `shopping_channel_categories` is different with 
/// {@link shopping_sections}. {@link shopping_sections} refers to a "corner" 
/// that is independent spatial information in the offline market, which cannot 
/// simultaneously classified in a {@link shopping_sales sale}. Besides, 
/// `shopping_channel_categories` can be classified into multiple categories 
/// in a {@link shopping_sales sale} simultaneously.
/// 
/// Product | Corner         | Categories
/// --------|----------------|--------------------------------------
/// Beef    | Butcher corner | Frozen food, Meat, **Favorite food**
/// Grape   | Fruit corner   | Fresh food, **Favorite food**
/// 
/// In addition, as `shopping_channel_categories` has 1:N self recursive 
/// relationship, it is possible to express below hierarchical structures. 
/// Thus, each channel can set their own category classification as they want.
///
///   - Food > Meat > Frozen
///   - Electronics > Notebook > 15 inches
///   - Miscellaneous > Wallet
/// 
/// Furthermore, `shopping_channel_categories` is designed to merge between 
/// themselves, so there is no burden to edit the category at any time.
///
/// @namespace Systematic
/// @erd Sales
/// @author Samchon
model shopping_channel_categories {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged channel's {@link shopping_channels.id}.
    ///
    /// @format uuid
    shopping_channel_id String @db.Uuid

    /// Parent category's {@link shopping_channel_categories.id}.
    ///
    /// Only when the category is a subcategory of another one.
    ///
    /// @format uuid
    parent_id String? @db.Uuid

    /// Name of category.
    name String @db.VarChar

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Updadte time of record.
    updated_at DateTime @db.Timestamptz

    /// Deletion time of record.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    channel                                   shopping_channels                           @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)
    parent                                    shopping_channel_categories?                @relation("shopping_channel_categories_children", fields: [parent_id], references: [id], onDelete: Cascade)
    children                                  shopping_channel_categories[]               @relation("shopping_channel_categories_children")
    shopping_sale_snapshot_channel_categories shopping_sale_snapshot_channel_categories[]
    shopping_coupon_channel_criterias         shopping_coupon_channel_criterias[]

    @@unique([shopping_channel_id, parent_id, name])
    @@index([parent_id, name])
    @@index([name])
}

/// Section information.
///
/// `shopping_sections` is a concept that refers to the spatial information 
/// of the market.
///
/// If we compare the section mentioned here to the offline market, it means 
/// a spatially separated area within the store, such as the "fruit corner" 
/// or "butcher corner". Therefore, in the {@link shopping_sales sale} entity, 
/// it is not possible to classify multiple sections simultaneously, but only 
/// one section can be classified.
///
/// By the way, if your shopping mall system requires only one section, then 
/// just use only one. This concept is designed to be expandable in the future.
///
/// @namespace Systematic
/// @erd Sales
/// @author Samchon
model shopping_sections {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Identifier code.
    code String @db.VarChar

    /// Name of section.
    name String @db.VarChar

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Update time of record.
    updated_at DateTime @db.Timestamptz

    /// Deletion time of record.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    shopping_sales                    shopping_sales[]
    shopping_coupon_section_criterias shopping_coupon_section_criterias[]

    @@unique([code])
    @@unique([name])
}

//-----------------------------------------------------------
// ACTORS
//-----------------------------------------------------------
/// Customer information, but not a person but a **connection** basis.
///
/// `shopping_customers` is an entity that literally embodies the information 
/// of those who participated in the market as customers. However, 
/// `shopping_customers` is different from {@link shopping_sellers} or 
/// {@link shopping_administrators}, where each person has one record based on 
/// membership registration. `shopping_customers` issues a new record every 
/// time it **connects**, even if it is the same person.
/// 
/// The first purpose of this is to track the customer's inflow path in detail, and it is 
/// for cases where the same person enters as a non-member, puts items in the 
/// {@link shopping_cart_commodities shopping cart} in advance, and only authenticates 
/// their real name or registers/logs in at the moment of 
/// {@link shopping_order_publishes payment}. It is the second. Lastly, it is 
/// to accurately track the activities that a person performs at the 
/// shopping mall in various ways, such as the same person accessing an 
/// {@link shopping_external_users external service} to make a purchase, 
/// creating multiple {@link shopping_members accounts} to make a purchase, 
/// and making a purchase as a non-member with only 
/// {@link shopping_citizens real name authentication}.
/// 
/// Therefore, `shopping_customers` can have multiple records with the same 
/// {@link shopping_citizens}, {@link shopping_members}, and 
/// {@link shopping_external_users}. Additionally, if a customer signs up for 
/// membership after verifying their real name or signs up for our service 
/// after being a user of an external service, all related records are changed 
/// at once. Therefore, identification and tracking of customers can be done 
/// very systematically.
///
/// @namespace Actors
/// @erd Coins
/// @author Samchon
model shopping_customers {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged channel's {@link shopping_channels.id}
    ///
    /// @format uuid
    shopping_channel_id String @db.Uuid /// @format uuid

    /// Belonged member's {@link shopping_members.id}
    ///
    /// @format uuid
    shopping_member_id String? @db.Uuid /// @format uuid

    /// Belonged external service user's {@link shopping_external_users.id}
    ///
    /// @format uuid
    shopping_external_user_id String? @db.Uuid /// @format uuid

    /// Belonged citizen's {@link shopping_citizens.id}
    ///
    /// @format uuid
    shopping_citizen_id String? @db.Uuid /// @format uuid

    /// Connection URL.
    ///
    /// {@link window.location.href}
    ///
    /// @format url
    href String @db.VarChar /// @format url

    /// Referrer URL.
    ///
    /// {@link window.document.referrer}
    ///
    /// @format url
    referrer String @db.VarChar /// @format url

    /// IP address,
    ///
    /// @pattern ((^\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\s*$)|(^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$))
    ip String @db.VarChar

    /// Creation time of record.
    ///
    /// It means the time when the customer connected to the shopping mall.
    created_at DateTime @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged channel.
    channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)

    /// Belonged member.
    member shopping_members? @relation(fields: [shopping_member_id], references: [id], onDelete: Cascade)

    /// Belonged external user.
    external_user shopping_external_users? @relation(fields: [shopping_external_user_id], references: [id], onDelete: Cascade)

    /// Belonged citizen.
    citizen                                 shopping_citizens?                        @relation(fields: [shopping_citizen_id], references: [id], onDelete: Cascade)
    shopping_carts                          shopping_carts[]
    shopping_orders                         shopping_orders[]
    shopping_coupon_tickets                 shopping_coupon_tickets[]
    shopping_deposit_charges                shopping_deposit_charges[]
    shopping_sale_snapshot_inquiries        shopping_sale_snapshot_inquiries[]
    shopping_sale_snapshot_inquiry_comments shopping_sale_snapshot_inquiry_comments[]
}

/// External user information.
/// 
/// `shopping_external_users` is an entity dsigned for when this system needs 
/// to connect with external services and welcome their users as customers of 
/// this service.
/// 
/// For reference, customers who connect from an external service must have 
/// this record, and the external service user is identified through the two 
/// attributes `application` and `uid`. If a customer connected from an 
/// external service completes {@link shopping_citizens real-name authentication} 
/// from this service, each time the external service user reconnects to this 
/// service and issues a new {@link shopping_customers customer} authentication 
/// token, {@link shopping_citizens real-name authentication} begins with 
/// completed.
/// 
/// And `password` is the password issued to the user by the external service 
/// system (the so-called permanent user authentication token), and is never 
/// the actual user password. However, for customers who entered the same 
/// `application` and `uid` as the current external system user, this is to 
/// determine whether to view this as a correct external system user or a 
/// violation.
/// 
/// In addition, additional information received from external services can 
/// be recorded in the `data` field in JSON format.
///
/// @namespace Actors
/// @author Samchon
model shopping_external_users {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Identifier code of the external service.
    ///
    /// It can be same with {@link shopping_channels_code} in common.
    application String @db.VarChar

    /// Identifier key of external user from the external system.
    uid String @db.VarChar

    /// Nickname of external user in the external system.
    nickname String @db.VarChar

    /// Additional information about external user from the external system.
    data String?

    /// Password of external user from the external system.
    ///
    /// This is a password issued to the user by an external service, and is 
    /// by no means the actual user password. However, for customers who 
    /// entered the same application and code as the current external system 
    /// user, this is to determine whether to view this as a correct external 
    /// system user or a violation.
    password String @db.VarChar

    /// Creation time of record.
    ///
    /// Another word, first time when the external user connected.
    created_at DateTime

    //----
    // RELATIONS
    //----
    shopping_customers shopping_customers[]

    @@unique([application, uid])
    @@unique([application, nickname])
}

/// Citizen verification information.
/// 
/// `shopping_citizens` is an entity that records the user's real name and 
/// mobile input information.
/// 
/// For reference, in South Korea, real name authentication is required for 
/// e-commerce participants, so the `name` attribute is important. However, 
/// the situation is different overseas, so in reality, `mobile` attributes 
/// are the most important, and identification of individual users is also 
/// done based on this mobile.
/// 
/// Of course, real name and mobile phone authentication information are 
/// encrypted and stored.
///
/// @namespace Actors
/// @erd Coins
/// @author Samchon
model shopping_citizens {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged channel's {@link shopping_channels.id}
    ///
    /// This is to manage personal information separately for each channel, 
    /// and also to recognize cases where the same citizen is authenticated 
    /// through different channels.
    ///
    /// @format uuid
    shopping_channel_id String? @db.Uuid

    /// Mobile phone number.
    ///
    /// @pattern ^[0-9]*$
    mobile String @db.VarChar

    /// Real name, or equivalent name identifiable.
    name String @db.VarChar

    /// Creation time of record.
    ///
    /// In other words, the 1st time of citizen activation.
    created_at DateTime @db.Timestamptz

    /// Deletion time of record.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    channel                    shopping_channels?           @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)
    shopping_customers         shopping_customers[]
    shopping_members           shopping_members[]
    shopping_deposit_histories shopping_deposit_histories[]
    shopping_mileage_histories shopping_mileage_histories[]
}

/// Member Account.
/// 
/// `shopping_members` is an entity that symbolizes the case when a user 
/// signs up as a member of this system.
/// 
/// In addition, `shopping_members` itself is a supertype entity, forming 
/// and managing subtypes for various types of members. However, 
/// {@link shopping_customers} are an exception, and due to the nature of 
/// their records being created on a per-connection basis, they are not 
/// divided into separate subtype entities when they sign up for membership.
/// 
/// For reference, `shopping_members` allows multiple subtypes. Therefore, 
/// it is also possible for a {@link shopping_citizens citizen} to be sometimes 
/// a {@link shopping_customers customer}, sometimes a 
/// {@link shopping_sellers seller}, sometimes an 
/// {@link shopping_administrators administrator}, and so on. 
/// 
/// Of course, this is according to system theory, and it is unclear what 
/// the planning will be like.
///
/// @namespace Actors
/// @author Samchon
model shopping_members {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged channel's {@link shopping_channels.id}
    ///
    /// @format uuid
    shopping_channel_id String @db.Uuid

    /// Belonged citizen's {@link shopping_citizens.id}
    ///
    /// @format uuid
    shopping_citizen_id String? @db.Uuid

    /// Nickname.
    nickname String @db.VarChar

    /// Password for log-in.
    password String @db.VarChar

    /// Creation time of record.
    ///
    /// In other words, the joining time.
    created_at DateTime @db.Timestamptz

    /// Update time of record.
    updated_at DateTime @db.Timestamptz

    /// Deletion time of record.
    withdrawn_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged channel.
    channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)

    /// Belonged citizen.
    citizen shopping_citizens? @relation(fields: [shopping_citizen_id], references: [id], onDelete: Cascade)

    /// List of customer records (connections).
    customers shopping_customers[]

    /// List of email addresses.
    emails shopping_member_emails[]

    of_seller shopping_sellers?
    of_admin  shopping_administrators?
}

/// Email address of member.
///
/// This system allows multiple email addresses to be registered for one
/// {@link shopping_members member}. If you don't have to plan such multiple
/// email addresses, just use only one.
///
/// @namespace Actors
/// @author Samchon
model shopping_member_emails {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged channel's {@link shopping_channels.id}
    ///
    /// Duplicated attribute with {@link shopping_members.channel_id}, but
    /// just denormalized for composing unique constraint.
    ///
    /// @format uuid
    shopping_channel_id String @db.Uuid

    /// Belonged member's {@link shopping_members.id}
    /// 
    /// @format uuid
    shopping_member_id String @db.Uuid

    /// Email address.
    ///
    /// @format email
    value String @db.VarChar

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    //----
    // RELATIONS
    //----
    channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)
    member  shopping_members  @relation(fields: [shopping_member_id], references: [id], onDelete: Cascade)
}

/// Seller information.
///
/// `shopping_sellers` is a subtype entity of {@link shopping_members}, and
/// it means a person who registers {@link shopping_sales sales} to operate
/// selling activities.
///
/// @namespace Actors
/// @erd Sales
/// @author Samchon
model shopping_sellers {
    //----
    // COLUMNS
    //----
    /// PK + FK.
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// Creation time of record.
    ///
    /// Joining time as seller, and it can be different with 
    /// {@link shopping_members membership} joining time.
    created_at DateTime @db.Timestamptz

    /// Withdrawal time.
    ///
    /// It can be different with {@link shopping_members.deleted_at}.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    base                                    shopping_members                          @relation(fields: [id], references: [id], onDelete: Cascade)
    shopping_sales                          shopping_sales[]
    shopping_order_goods                    shopping_order_goods[]
    shopping_deliveries                     shopping_deliveries[]
    shopping_coupons                        shopping_coupons[]
    shopping_coupon_seller_criterias        shopping_coupon_seller_criterias[]
    shopping_sale_snapshot_inquiry_answers  shopping_sale_snapshot_inquiry_answers[]
    shopping_sale_snapshot_inquiry_comments shopping_sale_snapshot_inquiry_comments[]
}

/// Administrator account.
///
/// @todo Not detailed yet.
/// @namespace Actors
/// @author Samchon
model shopping_administrators {
    //----
    // COLUMNS
    //----
    /// PK + FK.
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// Creation time of record.
    ///
    /// Joining time as an administrator, and can be different with
    /// {@link shopping_members membership} joining time.
    created_at DateTime @db.Timestamptz

    /// Deletion time of record.
    ///
    /// Withdrawal time from administrator, and can be different with
    /// {@link shopping_members.deleted_at}.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    base             shopping_members   @relation(fields: [id], references: [id], onDelete: Cascade)
    shopping_coupons shopping_coupons[]
}

/// The address information.
///
/// @namespace Actors
/// @erd Orders
/// @author Samchon
model shopping_addresses {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Mobile number.
    mobile String @db.VarChar

    /// Representative name of the address.
    ///
    /// Sometimes be receiver's name, and sometimes be place name.
    name String @db.VarChar

    /// Target country.
    country String @db.VarChar

    /// Target province.
    province String @db.VarChar

    /// Target city.
    city String @db.VarChar

    /// Department name.
    department String @db.VarChar

    /// Detailed address containing room number.
    possession String @db.VarChar

    /// Zip code, or postal code.
    zip_code String @db.VarChar

    /// Special description if required.
    special_note String? @db.VarChar

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// List of orders.
    orders shopping_orders[]

    @@index([mobile])
    @@index([name])
}

//-----------------------------------------------------------
// SALES
//-----------------------------------------------------------
/// Seller **sales** products.
/// 
/// `shopping_sales` is an entity that embodies "product sales" (sales) 
/// information registered by the {@link shopping_sellers seller}. And the 
/// main information of the sale is recorded in the sub 
/// {@link shopping_sale_snapshots}, not in the main `shopping_sales`. 
/// When a seller changes a previously registered item, the existing 
/// `shopping_sales` record is not changed, but a new snapshot record is 
/// created.
/// 
/// This is to preserve the {@link shopping_customers customer}'s 
/// {@link shopping_orders purchase history} flawlessly after the customer 
/// purchases a specific item, even if the seller changes the components or 
/// price of the item. It is also intended to support sellers in so-called 
/// A/B testing, which involves changing components or prices and measuring 
/// the performance in each case.
///
/// @namespace Sales
/// @erd Systematic
/// @author Samchon
model shopping_sales {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged section's {@link shopping_sections.id}
    ///
    /// @format uuid
    shopping_section_id String @db.Uuid

    /// Belonged seller's {@link shopping_sellers.id}
    ///
    /// @format uuid
    shopping_seller_id String @db.Uuid

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Opening time of sale.
    ///
    /// If `null` value assigned, it means not opened yet.
    opened_at DateTime? @db.Timestamptz

    /// Closing time of sale.
    ///
    /// If `null` value assigned, the sale is forever.
    closed_at DateTime? @db.Timestamptz

    /// Paused time.
    ///
    /// The time when seller paused the sale in some reason.
    ///
    /// {@link shopping_customers Customers} still can see the sale in list 
    /// and detail page, but a label "The sale is paused for a while by seller" 
    /// be attached.
    paused_at DateTime? @db.Timestamptz

    /// Suspended time.
    ///
    /// The time when seller suspended the sale in some reason.
    ///
    /// {@link shopping_customers Customers} can't see the sale in list and 
    /// detail page. It seems almost ssame with soft deletion, but there're 
    /// some differences. 
    ///
    /// At 1st, seller and {@link shopping_administrators administrator} can
    /// see suspended sale in list and detail page. At 2nd, seller can
    /// resume the sale at any time.
    suspended_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    section shopping_sections @relation(fields: [shopping_section_id], references: [id], onDelete: Cascade)
    seller  shopping_sellers  @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)

    snapshots                      shopping_sale_snapshots[]
    shopping_coupon_sale_criterias shopping_coupon_sale_criterias[]
}

/// Sale snapshot information.
/// 
/// `shopping_sale_snapshots` is an entity representing snapshot record of
/// belonged {@link shopping_sales sale}. The snapshot record is created
/// whenever the seller newly creates or updates the sale.
///
/// Sale | Cart | Order
/// -----|------|------
/// x | {@link shopping_carts} | {@link shopping_orders}
/// {@link shopping_sale_snapshots} | {@link shopping_cart_commodities} | {@link shopping_order_goods}
/// {@link shopping_sale_snapshot_unit_stocks} | {@link shopping_cart_commodity_stocks} | x
///
/// @namespace Sales
/// @erd Systematic
/// @erd Inquiries
/// @erd Carts
/// @author Samchon
model shopping_sale_snapshots {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged sale's {@link shopping_sales.id}
    ///
    /// @format uuid
    shopping_sale_id String @db.Uuid

    /// Creation time of record.
    ///
    /// It means the time when the seller created or updated the sale.
    created_at DateTime @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged sale.
    sale                             shopping_sales                     @relation(fields: [shopping_sale_id], references: [id], onDelete: Cascade)
    shopping_sale_snapshot_contents  shopping_sale_snapshot_contents?
    shopping_sale_snapshot_channels  shopping_sale_snapshot_channels[]
    shopping_sale_snapshot_units     shopping_sale_snapshot_units[]
    shopping_cart_commodities        shopping_cart_commodities[]
    shopping_sale_snapshot_inquiries shopping_sale_snapshot_inquiries[]
}

/// Content information of sale snapshot.
///
/// `shopping_sale_snapshot_contents` is an entity embodies the body contents 
/// of {@link shopping_sale_snapshots sale snapshot}. Also, it contains
/// revert policy of the sale.
///
/// @namespace Sales
/// @author Samchon
model shopping_sale_snapshot_contents {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged snapshot's {@link shopping_sale_snapshots.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_id String @db.Uuid

    /// Title of the content.
    title String @db.VarChar

    /// Format of the body content.
    ///
    /// Same meaning with extension like `html`, `md`, `txt`.
    format String @db.VarChar

    /// The main body content.
    body String @db.Text

    /// Revert policy.
    ///
    /// This is essential in South Korea, but I don't know well in overseas.
    ///
    /// Just use when you need.
    revert_policy String? @db.VarChar

    //----
    // RELATIONS
    //----
    /// Belonged snapshot.
    snapshot shopping_sale_snapshots @relation(fields: [shopping_sale_snapshot_id], references: [id], onDelete: Cascade)

    @@unique([shopping_sale_snapshot_id])
    @@index([title])
}

/// Target channel of sale snapshot to sell.
/// 
/// `shopping_sale_snapshot_channels` is an entity that expresses through 
/// which {@link shopping_channels channel} a listing 
/// {@link shopping_sale_snapshots snapshot} is sold, and is designed to 
/// resolve the M:N relationship between two tables.
/// 
/// @namespace Sales
/// @erd Systematic
/// @author Samchon
model shopping_sale_snapshot_channels {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged snapshot's {@link shopping_sale_snapshots.id}.
    ///
    /// @format uuid
    shopping_sale_snapshot_id String @db.Uuid

    /// Belonged channel's {@link shopping_channels.id}.
    ///
    /// @format uuid
    shopping_channel_id String @db.Uuid

    //----
    // RELATIONS
    //----
    /// Belonged snapshot.
    snapshot shopping_sale_snapshots @relation(fields: [shopping_sale_snapshot_id], references: [id], onDelete: Cascade)

    /// Belonged channel.
    channel       shopping_channels                           @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)
    to_categories shopping_sale_snapshot_channel_categories[]

    @@unique([shopping_sale_snapshot_id, shopping_channel_id])
}

/// Category classification info of sale snapshot.
///
/// `shopping_sale_snapshot_channel_categories` is an entity that expresses 
/// which {@link shopping_channel_categories category} the listing 
/// {@link shopping_sale_snapshots snapshot} is classified into in each 
/// {@link shopping_channels channel}.
/// 
/// It is designed to resolve the M:N relationship between 
/// {@link shopping_sale_snapshots} and {@link shopping_channel_categories}, 
/// respectively. Of course, if the target category being referred to is a 
/// major category, all minor categories belonging to it can also be used.
///
/// @namespace Sales
/// @erd Systematic
/// @author Samchon
model shopping_sale_snapshot_channel_categories {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged assigned channel of sale snapshot's {@link shopping_sale_snapshot_channels.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_channel_id String @db.Uuid

    /// Belonged channel category's {@link shopping_channel_categories.id}
    ///
    /// @format uuid
    shopping_channel_category_id String @db.Uuid

    //----
    // RELATIONS
    //----
    /// Belonged assigned channel of sale snapshot.
    to_channel shopping_sale_snapshot_channels @relation(fields: [shopping_sale_snapshot_channel_id], references: [id], onDelete: Cascade)

    /// Belonged channel category.
    category shopping_channel_categories @relation(fields: [shopping_channel_category_id], references: [id], onDelete: Cascade)

    @@unique([shopping_sale_snapshot_channel_id, shopping_channel_category_id])
    @@index([shopping_channel_category_id])
}

/// Product composition information handled in the sale snapshot.
/// 
/// `shopping_sale_snapshot_units` is an entity that embodies the 
/// "individual product" information handled in the 
/// {@link shopping_sale_snapshots sale snapshot}.
/// 
/// For reference, the reason why `shopping_sale_snapshot_units` is separated 
/// from {@link shopping_sale_snapshots} by an algebraic relationship of 
/// 1: N is because there are often cases where multiple products are sold 
/// in one listing. This is the case with so-called "bundled products".
/// 
/// - Bundle from regular product (laptop set)
///   - main body
///   - keyboard
///   - mouse
///   - Apple Care (Free A/S Voucher)
/// 
/// And again, `shopping_sale_snapshot_units` does not in itself refer to 
/// the final {@link shopping_sale_snapshot_unit_stocks stock} that the 
/// customer will purchase. 
/// The {@link shopping_sale_snapshot_unit_stocks final stock} can be 
/// found only after selecting all given 
/// {@link shopping_sale_snapshot_unit_options options} and their 
/// {@link shopping_sale_snapshot_unit_option_candidates candidate} values.
/// 
/// For example, even if you buy a laptop, the 
/// {@link shopping_sale_snapshot_unit_stocks final stocks} are determined 
/// only after selecting all the 
/// {@link shopping_sale_snapshot_unit_options options} (CPU / RAM / SSD), etc.
///
/// @namespace Sales
/// @erd Carts
/// @author Samchon
model shopping_sale_snapshot_units {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged snapshot's {@link shopping_sale_snapshots.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_id String @db.Uuid

    /// Representative name of the unit.
    name String @db.VarChar

    /// Whether the unit is primary or not.
    ///
    /// Just a labeling value.
    primary Boolean @db.Boolean

    /// Whether the unit is required or not.
    ///
    /// When the unit is required, the customer must select the unit. If do
    /// not select, customer can't buy it.
    required Boolean @db.Boolean

    /// Sequence order in belonged snapshot.
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    /// Belonged snapshot.
    snapshot shopping_sale_snapshots @relation(fields: [shopping_sale_snapshot_id], references: [id], onDelete: Cascade)

    /// List of options.
    options shopping_sale_snapshot_unit_options[]

    /// List of stocks.
    stocks                         shopping_sale_snapshot_unit_stocks[]
    shopping_cart_commodity_stocks shopping_cart_commodity_stocks[]
}

/// Individual option information on units for sale.
/// 
/// `shopping_sale_snapshot_unit_options` is a subsidiary entity of 
/// {@link shopping_sale_snapshot_units} that represents individual products 
/// in the sale, and is an entity designed to represent individual option 
/// information for the unit.
/// 
/// - Examples of Options
///   - optional options
///     - Computer: CPU, RAM, SSD, etc.
///     - Clothes: size, color, style, etc.
///   - descriptive options
///     - Engrave
///     - Simple question
///
/// If the `type` of option is a `variable` value in `"select"`, the 
/// {@link shopping_sale_snapshot_unit_stocks final stock} that the customer 
/// will purchase changes depending on the selection of the 
/// {@link shopping_sale_snapshot_unit_option_candidates candidate} value.
///
/// Conversely, if it is a `type` other than `"select"`, or if the `type` 
/// is `"select"` but `variable` is `false`, this is an option that has no 
/// meaning beyond simple information transfer. Therefore, no matter what 
/// value the customer enters and chooses when purchasing it, the option in 
/// this case does not affect the 
/// {@link shopping_sale_snapshot_unit_stocks final stock}.
///
/// @namespace Sales
/// @erd Carts
/// @author Samchon
model shopping_sale_snapshot_unit_options {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged unit's {@link shopping_sale_snapshot_units.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_unit_id String @db.Uuid

    /// Name of the option.
    name String @db.VarChar

    /// Type of the option.
    ///
    /// - `select`: The way selecting one of the candidate values.
    /// - `boolean`
    /// - `number`
    /// - `string`
    type String @db.VarChar

    /// Whether the option is variable or not.
    ///
    /// When `type` of current option is `"select"`, this attribute means
    /// whether selecting different 
    /// {@link shopping_sale_snapshot_unit_option_candidate candidate} value 
    /// affects the {@link shopping_sale_snapshot_unit_stocks final stock}
    /// or not.
    ///
    /// For reference, if `type` value is not `"select"`, this attribute
    /// is always `false`.
    variable Boolean @db.Boolean

    /// Sequence order in belonged unit.
    ///
    /// @type int
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    /// Belonged unit.
    unit shopping_sale_snapshot_units @relation(fields: [shopping_sale_snapshot_unit_id], references: [id], onDelete: Cascade)

    /// List of candidates.
    candidates                            shopping_sale_snapshot_unit_option_candidates[]
    shopping_cart_commodity_stock_choices shopping_cart_commodity_stock_choices[]

    @@unique([shopping_sale_snapshot_unit_id, name])
}

/// Selectable candidate values within an option.
/// 
/// `shopping_sale_snapshot_unit_option_candidates` is an entity that 
/// represents individual candidate values that can be selected from 
/// {@link shopping_sale_snapshot_unit_options options} of the "select" type.
/// 
/// - Example
///   - RAM: 8GB, 16GB, 32GB
///   - GPU: RTX 3060, RTX 4080, TESLA
///   - License: Private, Commercial, Educatiion
/// 
/// By the way, if belonged {@link shopping_sale_snapshot_unit_options option} 
/// is not "select" type, this entity never being used.
///
/// @namespace Sales
/// @erd Carts
/// @author Samchon
model shopping_sale_snapshot_unit_option_candidates {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged option's {@link shopping_sale_snapshot_unit_options.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_unit_option_id String @db.Uuid

    /// Representative name of candidate value.
    name String @db.VarChar

    /// Sequence order in option.
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    /// Belonged entity.
    option shopping_sale_snapshot_unit_options @relation(fields: [shopping_sale_snapshot_unit_option_id], references: [id], onDelete: Cascade)

    /// List of choices in stock.
    choices                               shopping_sale_snapshot_unit_stock_choices[]
    shopping_cart_commodity_stock_choices shopping_cart_commodity_stock_choices[]

    @@unique([shopping_sale_snapshot_unit_option_id, name])
}

/// Final component information on units for sale.
/// 
/// `shopping_sale_snapshot_unit_stocks` is a subsidiary entity of 
/// {@link shopping_sale_snapshot_units} that represents a product catalog 
/// for sale, and is a kind of final stock that is constructed by selecting 
/// all {@link shopping_sale_snapshot_unit_options options} 
/// (variable "select" type) and their 
/// {@link shopping_sale_snapshot_unit_option_candidates candidate} values in 
/// the belonging unit. It is the "good" itself that customers actually 
/// purchase.
/// 
/// - Product Name) MacBook
///   - Options
///     - CPU: { i3, i5, i7, i9 }
///     - RAM: { 8GB, 16GB, 32GB, 64GB, 96GB }
///     - SSD: { 256GB, 512GB, 1TB }
///     - Number of final stocks: 4 * 5 * 3 = 60
///
/// For reference, the total number of `shopping_sale_snapshot_unit_stocks` 
/// records in an attribution unit can be obtained using Cartesian Product. 
/// In other words, the value obtained by multiplying all the candidate 
/// values that each (variable "select" type) option can have by the number 
/// of cases is the total number of final stocks in the unit. 
///
/// Of course, without a single variable "select" type option, the final 
/// stocks count in the unit is only 1.
///
/// @namespace Sales
/// @erd Carts
/// @author Samchon
model shopping_sale_snapshot_unit_stocks {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged unit's {@link shopping_sale_snapshot_units.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_unit_id String @db.Uuid

    /// Name of the final stock.
    name String @db.VarChar

    /// Nominal price.
    ///
    /// This is not real price to pay, but just a nominal price to show.
    /// If this value is greater than the `real_price`, it would be shown
    /// like seller is giving a discount.
    ///
    /// @minimum 0
    nominal_price Float @db.DoublePrecision

    /// Real price to pay.
    ///
    /// @minimum 0
    real_price Float @db.DoublePrecision

    /// Tax to pay.
    ///
    /// @minimum 0
    tax Float @db.DoublePrecision

    /// Sequence order in belonged unit.
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    /// Belonged unit.
    unit shopping_sale_snapshot_units @relation(fields: [shopping_sale_snapshot_unit_id], references: [id], onDelete: Cascade)

    /// List of choices.
    ///
    /// Which candidate values are chosen in each option.
    choices                        shopping_sale_snapshot_unit_stock_choices[]
    shopping_cart_commodity_stocks shopping_cart_commodity_stocks[]

    @@unique([shopping_sale_snapshot_unit_id, name])
}

/// Selection information of final stock.
/// 
/// `shopping_sale_snapshot_unit_stock_choices` is an entity that represents 
/// which {@link shopping_sale_snapshot_unit_options option} of each `variable` 
/// "select" `type` was selected for each stock and which 
/// {@link shopping_sale_snapshot_unit_option_candidates candidate value} was 
/// selected within it.

/// Of course, if the bound {@link shopping_sale_snapshot_units unit} does not 
/// have any {@link shopping_sale_snapshot_unit_options options}, this entity 
/// can also be ignored.
///
/// @namespace Sales
/// @author Samchon
model shopping_sale_snapshot_unit_stock_choices {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged stock's {@link shopping_sale_snapshot_unit_stocks.id}
    /// 
    /// @format uuid
    shopping_sale_snapshot_unit_stock_id String @db.Uuid

    /// Belonged candidate's {@link shopping_sale_snapshot_unit_option_candidates.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_unit_option_candidate_id String @db.Uuid

    /// Sequence order in belonged stock.
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    /// Belonged stock.
    stock shopping_sale_snapshot_unit_stocks @relation(map: "fk_shopping_sale_snapshot_unit_stock_choices_stock", fields: [shopping_sale_snapshot_unit_stock_id], references: [id], onDelete: Cascade)

    /// Belonged candidate.
    candidate shopping_sale_snapshot_unit_option_candidates? @relation(map: "fk_shopping_sale_snapshot_unit_stock_choices_candidate", fields: [shopping_sale_snapshot_unit_option_candidate_id], references: [id], onDelete: Cascade)

    @@unique([shopping_sale_snapshot_unit_stock_id, shopping_sale_snapshot_unit_option_candidate_id])
}

//-----------------------------------------------------------
// CARTS
//-----------------------------------------------------------
/// Shopping Cart.
///
/// `shopping_carts` is literally a space where 
/// {@link shopping_customers customer} temporarily stores products before
/// {@link shopping_orders purchase}.
///
/// Sale | Cart | Order
/// -----|------|------
/// x | {@link shopping_carts} | {@link shopping_orders}
/// {@link shopping_sale_snapshots} | {@link shopping_cart_commodities} | {@link shopping_order_goods}
/// {@link shopping_sale_snapshot_unit_stocks} | {@link shopping_cart_commodity_stocks} | x
/// 
/// @namespace Carts
/// @author Samchon
model shopping_carts {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged customer's {@link shopping_customers.id}
    ///
    /// @format uuid
    shopping_customer_id String @db.Uuid

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged customer.
    customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)

    /// List of commodities containing sale snapshot.
    commodities shopping_cart_commodities[]
}

/// Item in a shopping cart.
///
/// `shopping_cart_commodities` is an entity that represents a 
/// {@link shopping_sale_snapshots snapshot} of the items that 
/// {@link shopping_customers customer} has placed into his 
/// {@link shopping_carts shopping cart} with a 
/// {@link shopping_orders purchase} in mind. And if the customer continues 
/// this into an actual {@link shopping_orders order} in the future, 
/// `shopping_cart_commodities` be changed to {@link shopping_order_goods}.
/// 
/// And while adding a sale snapshot to the shopping cart, the customer 
/// inevitably selects specific {@link shopping_sale_snapshot_units units} and 
/// {@link shopping_sale_snapshot_unit_stocks final stocks} within the listing 
/// snapshot. Information about these units and stocks is recorded in the 
/// subsidiary entity {@link shopping_cart_commodity_stocks}. There is also an 
/// attribute `volume` that indicates how many sets of snapshots of the 
/// target commodity will be purchased. This "volume" is a value that will be 
/// multiplied by {@link shopping_cart_commodity_stocks.quantity}, the quantity 
/// for each component.
///
/// 
/// @namespace Carts
/// @author Samchon
model shopping_cart_commodities {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged cart's {@link shopping_carts.id}
    ///
    /// @format uuid
    shopping_cart_id String @db.Uuid

    /// Target snapshot's {@link shopping_sale_snapshots.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_id String @db.Uuid

    /// Volume count.
    ///
    /// The value multiplied to {@link shopping_cart_commodity_stocks.quantity}.
    ///
    /// @format uint 
    /// @minimum 1
    volume Int @db.Integer

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Whether be published or not.
    ///
    /// Is current commodity ordered and be paid?
    ///
    /// Until purchase the commodity, the commodity can be reused to create new 
    /// cart commodity. This variable can be computed by referencing 
    /// {@link Orders order} related tables, but just denormalized for the
    /// performance reason.
    published Boolean

    //----
    // RELATIONS
    //----
    /// Belonged cart.
    cart shopping_carts @relation(fields: [shopping_cart_id], references: [id], onDelete: Cascade)

    /// Target snapshot.
    snapshot shopping_sale_snapshots @relation(fields: [shopping_sale_snapshot_id], references: [id], onDelete: Cascade)

    /// List of wrapper of final stocks.
    stocks shopping_cart_commodity_stocks[]

    /// List of order goods for purchase.
    order_goods shopping_order_goods[]

    @@index([shopping_cart_id, created_at])
    @@index([shopping_sale_snapshot_id])
}

/// Final stock information of commodity added to the shopping cart.
/// 
/// `shopping_cart_commodity_stocks` is a subsidiary entity of 
/// {@link shopping_cart_commodities} that embodies the information of the 
/// {@link shopping_sale_snapshots snapshot} of the items in the shopping cart, 
/// and is a concept that corresponds to the individual 
/// {@link shopping_sale_snapshot_units units} in the target item snapshot 
/// and the {@link shopping_sale_snapshot_unit_stocks stock} finally selected 
/// among those {@link shopping_sale_snapshot_units units}.
/// 
/// Therefore, if the customer selects multiple units and stocks from the 
/// target sale snapshot, the attributed {@link shopping_cart_commodities} record 
/// also has multiple corresponding `shopping_cart_commodity_stocks` records.
/// 
/// And `shopping_cart_commodity_stocks` has a `quantity` property that indicates 
/// how many final stocks would be purchased in total. The final quantity 
/// actually purchased can be multiplied by the 
/// {@link shopping_cart_commodities.volume} value of the parent entity.
///
/// @namespace Carts
/// @author Samchon
model shopping_cart_commodity_stocks {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged commodity's {@link shopping_cart_commodities.id}
    ///
    /// @format uuid
    shopping_cart_commodity_id String @db.Uuid

    /// Target unit's {@link shopping_sale_snapshot_units.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_unit_id String @db.Uuid

    /// Target final stock's {@link shopping_sale_snapshot_unit_stocks.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_unit_stock_id String @db.Uuid

    /// Quantity count.
    ///
    /// @type uint 
    /// @minimum 1
    quantity Int @db.Integer

    /// Sequence order in belonged cart commodity.
    ///
    /// @type int
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    /// Belonged cart commodity.
    commodity shopping_cart_commodities @relation(fields: [shopping_cart_commodity_id], references: [id], onDelete: Cascade)

    /// Target unit.
    unit shopping_sale_snapshot_units @relation(map: "rel_shopping_cart_commodity_stocks_unit", fields: [shopping_sale_snapshot_unit_id], references: [id], onDelete: Cascade)

    /// Target final stock.
    stock shopping_sale_snapshot_unit_stocks @relation(map: "rel_shopping_cart_commodity_stocks_stock", fields: [shopping_sale_snapshot_unit_stock_id], references: [id], onDelete: Cascade)

    /// List of choices, how customer has determined for each option.
    choices                  shopping_cart_commodity_stock_choices[]
    shopping_delivery_pieces shopping_delivery_pieces[]

    @@index([shopping_cart_commodity_id])
    @@index([shopping_sale_snapshot_unit_id], map: "idx_shopping_cart_commodity_stocks_unit")
    @@index([shopping_sale_snapshot_unit_stock_id], map: "idx_shopping_cart_commodity_stocks_stock")
}

/// Option choice information for the final stock added to the shopping cart.
/// 
/// `shopping_cart_commodity_stock_choices` is a subsidiary entity of 
/// {@link shopping_cart_commodity_stocks}. It records which 
/// {@link shopping_sale_snapshot_unit_options options} the customer 
/// specifically used while putting a specific 
/// {@link shopping_sale_snapshot_units unit} and specific 
/// {@link shopping_sale_snapshot_unit_stocks stock} of the 
/// {@link shopping_sale_snapshots sale snapshot} in the shopping cart, and 
/// which {@link shopping_sale_snapshot_unit_option_candidates candidate values} 
/// were selected or listed within the shopping cart.
/// 
/// Therefore, `shopping_cart_commodity_stock_choices` has reference properties 
/// and predicate properties for candidate values in addition to references 
/// to options. If the `type` of target option is "select", enter the 
/// candidate value selected by the customer. Otherwise, enter the value 
/// entered by the customer.
///
/// @namespace Carts
/// @author Samchon
model shopping_cart_commodity_stock_choices {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged cart-commodity-stock's {@link shopping_cart_commodity_stocks.id}
    ///
    /// @format uuid
    shopping_cart_commodity_stock_id String @db.Uuid

    /// Target option's {@link shopping_sale_snapshot_unit_options.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_unit_option_id String @db.Uuid

    /// Selected candidate's {@link shopping_sale_snapshot_unit_option_candidates.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_unit_option_candidate_id String? @db.Uuid

    /// User-written value for descriptive option.
    value String? @db.VarChar

    /// Sequence order in belonged cart-commodity-stock.
    ///
    /// @type int
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    /// Belonged cart-commodity-stock.
    stock shopping_cart_commodity_stocks @relation(fields: [shopping_cart_commodity_stock_id], references: [id], onDelete: Cascade)

    /// Target option.
    option shopping_sale_snapshot_unit_options @relation(map: "rel_shopping_cart_commodity_stock_choices_option", fields: [shopping_sale_snapshot_unit_option_id], references: [id], onDelete: Cascade)

    /// Selected candidate value for "select" typed option.
    candidate shopping_sale_snapshot_unit_option_candidates? @relation(map: "rel_shopping_cart_commodity_stock_choices_candidate", fields: [shopping_sale_snapshot_unit_option_candidate_id], references: [id], onDelete: Cascade)

    @@index([shopping_cart_commodity_stock_id])
    @@index([shopping_sale_snapshot_unit_option_id], map: "idx_shopping_cart_commodity_stock_choices_option")
    @@index([shopping_sale_snapshot_unit_option_candidate_id], map: "idx_shopping_cart_commodity_stock_choices_candidate")
}

//-----------------------------------------------------------
// ORDERS
//-----------------------------------------------------------
/// Order application information.
/// 
/// `shopping_orders` is an entity that embodies 
/// {@link shopping_customers customer}'s order application information. 
/// However, please note that at this time, you are still at the 
/// "order application" stage and not the "order confirmation" stage.
/// 
/// And as soon as a customer applies for an order, all 
/// {@link shopping_cart_commodities commodities} in the target shopping cart are 
/// promoted to {@link shopping_order_goods}, and those 
/// {@link shopping_order_goods} records are created under this 
/// `shopping_orders`. 
///
/// Of course, not all commodities in the target shopping cart become 
/// {@link shopping_order_goods}, but only those selected by the customer 
/// become the {@link shopping_order_goods}.
/// 
/// Sale | Cart | Order
/// -----|------|------
/// x | {@link shopping_carts} | {@link shopping_orders}
/// {@link shopping_sale_snapshots} | {@link shopping_cart_commodities} | {@link shopping_order_goods}
/// {@link shopping_sale_snapshot_unit_stocks} | {@link shopping_cart_commodity_stocks} | x
///
/// @namespace Orders
/// @author Samchon
model shopping_orders {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged customer's {@link shopping_customers.id}
    ///
    /// @format uuid
    shopping_customer_id String @db.Uuid

    /// Target address' {@link shopping_addresses id}
    ///
    /// @format uuid
    shopping_address_id String? @db.Uuid

    /// Amount of cash payment.
    ///
    /// @minimum 0
    cash Float @db.DoublePrecision

    /// Amount of deposit payment instead of cash.
    ///
    /// @minimum 0
    deposit Float @db.DoublePrecision

    /// Amount of mileage payment instead of cash.
    ///
    /// @minimum 0
    mileage Float @db.DoublePrecision

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Deletion time of record.
    ///
    /// If order be published, unable to erase it. In that case, you
    /// {@link shopping_order_publishes.cancelled_at} instead, or utilize
    /// {@link shopping_order_good_reverts} instead.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged customer.
    customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)

    /// Target address.
    address shopping_addresses? @relation(fields: [shopping_address_id], references: [id], onDelete: Cascade)

    /// Publish information.
    publish shopping_order_publishes?

    /// List of goods to purchase.
    goods shopping_order_goods[]

    /// List of payed tickets for discount
    ticket_payments shopping_coupon_ticket_payments[]

    @@index([shopping_customer_id, created_at])
}

/// Information about the individual goods that make up your order.
/// 
/// `shopping_order_goods` is an entity that represents each good ordered 
/// by a {@link shopping_customers customer}, and the record is created in the 
/// process of upgrading the product {@link shopping_cart_commodities commodity} 
/// in the {@link shopping_carts shopping cart} to a good due to the customer's 
/// {@link shopping_orders order request}.
/// 
/// And `shopping_order_goods`, like {@link shopping_cart_commodities}, is a concept 
/// that corresponds to the listing 
/// {@link shopping_sale_snapshots sale snapshot}.
/// 
/// For reference, `shopping_order_goods` also contains `volume` information 
/// separately from the belonging {@link shopping_cart_commodities.volume}. This is 
/// because there are often cases where you put 3 books in your shopping cart 
/// and then change them to 4 during the actual order application process. 
/// This is to increase the reusability of the shopping cart by changing the 
/// volume attribute of the current entity rather than directly changing the 
/// shopping_cart_commodities information.
/// 
/// In addition, `shopping_order_goods` becomes the most basic unit for 
/// the post-order process, that is, after-sales service (A/S). For example, 
/// after receiving a customer's product, confirming the order is recorded 
/// in the `confirmed_at` attribute. Additionally, `shopping_order_goods` is 
/// the unit in which customers issue issues or request exchanges or refunds 
/// for ordered products.
///
/// @namespace Orders
/// @author Samchon
model shopping_order_goods {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged order's {@link shopping_orders.id}
    /// 
    /// @format uuid
    shopping_order_id String @db.Uuid

    /// Belonged cart commodity's {@link shopping_cart_commodities.id}
    ///
    /// @format uuid
    shopping_cart_commodity_id String @db.Uuid

    /// Belonged seller's {@link shopping_sellers.id}
    ///
    /// It can be computed by referencing related {@link shopping_sales},
    /// but denormalized for performance reason.
    ///
    /// @format uuid
    shopping_seller_id String @db.Uuid

    /// Volume count.
    ///
    /// The value multiplied to {@link shopping_cart_commodity_stocks.quantity}.
    /// It's purpose is exactly same with {@link shopping_cart_commodities.volume},
    /// but rewritten because the {@link shopping_cart_commodities} records are
    /// reusable until payment.
    ///
    /// @format uint 
    /// @minimum 1
    volume Int @db.Integer

    /// Sequence order(?) in belonged order.
    ///
    /// @format int
    sequence Int @db.Integer

    /// Confirmation time of order good.
    ///
    /// When be confirmed, customer can't request refund or exchange.
    ///
    /// The confirmation be accomplished by following cases.
    ///
    /// - Customer does it directly.
    /// - 14 days after the delivery.
    confirmed_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged order.
    order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)

    /// Belonged cart commodity.
    commodity shopping_cart_commodities @relation(fields: [shopping_cart_commodity_id], references: [id], onDelete: Cascade)

    /// Belonged seller.
    seller                         shopping_sellers                 @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)
    shopping_delivery_pieces       shopping_delivery_pieces[]
    shopping_sale_snapshot_reviews shopping_sale_snapshot_reviews[]

    @@index([shopping_order_id])
    @@index([shopping_cart_commodity_id])
}

/// Order completion and payment information.
/// 
/// `shopping_order_publishes` is an entity that embodies the series of 
/// processes in which a customer pays for his or her 
/// {@link shopping_orders order}, thereby completing the order. And only after 
/// the order is completed, can the seller recognize that the customer has 
/// purchased his product.
/// 
/// By the way, please note that just because the `shopping_order_publishes` 
/// record exists, it does not mean that the payment has been completed. 
/// Of course, with "credit cards" and "Google Pay", payment application and 
/// payment occur at the same time. However, there are often cases where 
/// payment is made after the payment application, such as "bank transfer" or 
/// "virtual account payment". Therefore, to see the completion of payment, 
/// be sure to check the `paid_at` property.
/// 
/// In addition, even after payment has been made, there may be cases where 
/// it is suddenly canceled, so please be aware of this as well.
/// 
/// @namespace Orders
/// @author Samchon
model shopping_order_publishes {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged order's {@link shopping_orders.id}
    ///
    /// @format uuid
    shopping_order_id String @db.Uuid

    /// Password for encryption.
    ///
    /// This shopping mall system uses a randomly issued password to 
    /// encrypt payment history, and is completely unrelated to the user.
    password String? @db.VarChar

    /// Creation time of record.
    ///
    /// Note that, this property does not mean the payment completion time.
    created_at DateTime @db.Timestamptz

    /// Completion time of payment.
    ///
    /// This property is the only way to know if the payment has been
    /// completed. If this property is `null`, the payment has not been
    /// completed yet.
    paid_at DateTime? @db.Timestamptz

    /// The time when the payment was cancelled or reverted.
    cancelled_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged order.
    order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)

    @@unique([shopping_order_id])
}

/// Delivery information.
///
/// When delivering purchase(s) to {@link shopping_customers customer}, 
/// {@link shopping_selleres seller} can deliver multiple 
/// {@link shopping_sale_snapshot_unit_stocks stocks}, {@link shopping_order_goods goods} 
/// at once. Also, it is possible to deliver a stock or good in multiple times due to 
/// physical restriction like volume or weight.
///
/// As you can see from above, the relationship between delivery with 
/// {@link shopping_orders order} (or good) is not 1: 1 or N: 1, but M: N. Entity 
/// `shopping_deliveries` has been designed to represent such relationship, by referencing
/// target stocks or goods through subsidiary entity {@link shopping_delivery_pieces}.
///
/// Also, delivery does not end with only one step. It has multiple processes like
/// manufacturing, planning, shipping and delivering. Those steps are represented by
/// another subsidiary entity {@link shopping_delivery_journeys}.
///
/// @todo No shipper entity yet
/// @namespace Orders
/// @author Samchon
model shopping_deliveries {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged seller's {@link shopping_sellers id}
    ///
    /// @format uuid
    shopping_seller_id String @db.Uuid

    /// Invoice code if exists.
    invoice_code String? @db.VarChar

    //----
    // RELATIONS
    //----
    seller   shopping_sellers             @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)
    journeys shopping_delivery_journeys[]
    pieces   shopping_delivery_pieces[]
}

/// Which stocks are delivered.
///
/// @namespace Orders
/// @author Samchon
model shopping_delivery_pieces {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged delivery's {@link shopping_deliveries id}
    ///
    /// @format uuid
    shopping_delivery_id String @db.Uuid

    /// Target good's {@link shopping_order_goods id}
    ///
    /// @format uuid
    shopping_order_good_id String @db.Uuid

    /// Target stock-wrapper's {@link shopping_sale_snapshot_unit_stocks id}
    ///
    /// @format uuid
    shopping_cart_commodity_stock_id String @db.Uuid

    /// Quantity count.
    ///
    /// It can be precision value to express splitted shipping.
    ///
    /// @exclusiveMinimum 0
    quantity Float @db.DoublePrecision

    /// Sequence order in belonged delivery.
    ///
    /// @type int
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    delivery             shopping_deliveries            @relation(fields: [shopping_delivery_id], references: [id], onDelete: Cascade)
    good                 shopping_order_goods           @relation(fields: [shopping_order_good_id], references: [id], onDelete: Cascade)
    cart_commodity_stock shopping_cart_commodity_stocks @relation(fields: [shopping_cart_commodity_stock_id], references: [id], onDelete: Cascade)
}

/// Journey of delivery.
///
/// @namespace Orders
/// @author Samchon
model shopping_delivery_journeys {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// @format uuid
    shopping_delivery_id String @db.Uuid

    /// Type of journey.
    ///
    /// - preparing
    /// - shipping
    /// - delivering
    type String @db.VarChar

    /// Title of journey.
    title String? @db.VarChar

    /// Description of journey.
    description String?

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Start time of journey.
    started_at DateTime @db.Timestamptz

    /// Completion time of journey.
    completed_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged delivery.
    delivery shopping_deliveries @relation(fields: [shopping_delivery_id], references: [id], onDelete: Cascade)
}

//-----------------------------------------------------------
// COUPONS
//-----------------------------------------------------------
/// Discount coupon.
/// 
/// `shopping_coupons` is an entity that symbolizes discount coupons at a 
/// shopping mall.
/// 
/// Note that, `shopping_coupons` only contains specification information 
/// about discount coupons. Please keep in mind that this is a different 
/// concept from {@link shopping_coupon_tickets}, which refers to the issuance 
/// of a discount coupon, or {@link shopping_coupon_ticket_payments}, which 
/// refers to its payment.
/// 
/// Additionally, discount coupons are applied on an 
/// {@link shopping_orders order-by-order} basis, but each has its own unique 
/// restrictions. For example, a coupon with 
/// {@link shopping_coupon_seller_criterias} may or may not be used only for 
/// {@link shopping_sale_snapshots snapshots} of listings registered by the 
/// {@link shopping_sellers seller}. Also, there are restrictions such as 
/// minimum amount restrictions for using discount coupons and maximum discount 
/// amount limits.
/// 
/// In addition, you can set whether to issue discount coupons publicly or give 
/// them only to people who know the specific issuing code. In addition, there 
/// are restrictions such as issued discount coupons having an expiration date 
/// or being issued only to customers who came in through a specific channel.
/// 
/// For more information, please refer to the properties below and the 
/// subsidiary entities described later.
/// 
/// @namespace Coupons
/// @author Samchon
model shopping_coupons {
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged administrator's {@link administrators.id}
    ///
    /// @format uuid
    shopping_administrator_id String? @db.Uuid

    /// Belonged seller's {@link shopping_sellers.id}
    ///
    /// @format uuid
    shopping_seller_id String? @db.Uuid

    /// Reprensentative name of coupon.
    name String @db.VarChar

    /// Access level of coupon.
    ///
    /// - `public`: possible to find from public API
    /// - `private`: unable to find from public API
    ///   - arbitrarily assigned by the seller or administrator
    ///   - issued from one-time link
    access String @db.VarChar

    /// Exclusivity or not.
    /// 
    /// An exclusive discount coupon refers to a discount coupon that has an 
    /// exclusive relationship with other discount coupons and can only be used 
    /// alone. That is, when an exclusive discount coupon is used, no other 
    /// discount coupon can be used for the same {@link shopping_orders order} 
    /// or {@link shopping_order_goods good}.
    /// 
    /// Please note that this `exclusive` attribute is a very different 
    /// concept from `multiplicative`, which means whether the same coupon 
    /// can be multiplied and applied to multiple coupons of the same order, 
    /// so please do not confuse them.
    exclusive Boolean @db.Boolean

    /// Discount unit.
    ///
    /// - amount: Absolute value
    /// - percent: 0 ~ 100 %
    unit String @db.VarChar

    /// Discount value.
    ///
    /// If `unit` is percent, range of value is limited from 0 to 100.
    ///
    /// @exclusiveMinimum 0
    value Float @db.DoublePrecision

    /// Minimum purchase amount for discount.
    /// 
    /// When setting this value, discount coupons cannot be applied to 
    /// order totals that are less than this value.
    ///
    /// @exclusiveMinimum 0
    threshold Float? @db.DoublePrecision

    /// Maximum amount available for discount.
    /// 
    /// When this value is set, no further discount will be given no matter 
    /// how much you order.
    limit Int? @db.Integer /// @format uint @minimum 1

    /// Limited quantity issued.
    /// 
    /// If there is a limit to the quantity issued, it becomes impossible to 
    /// issue tickets exceeding this value.
    /// 
    /// In other words, the concept of N coupons being issued on a first-come, 
    /// first-served basis is created.
    ///
    /// @format uint 
    /// @minimum 1
    volume Int? @db.Integer

    /// Limited quantity issued per person.
    /// 
    /// As a limit to the total amount of issuance per person, it is common to 
    /// assign 1 to limit duplicate issuance to the same citizen, or to use 
    /// the `NULL` value to set no limit.
    /// 
    /// Of course, by assigning a value of N, the total amount issued to the 
    /// same citizen can be limited.
    ///
    /// @format uint 
    /// @minimum 1
    volume_per_citizen Int? @db.Integer

    /// Expiration day(s) value.
    /// 
    /// The concept of expiring N days after a discount coupon ticket is issued.
    /// 
    /// Therefore, customers must use the ticket within N days, if possible, 
    /// from the time it is issued.
    ///
    /// @format uint 
    /// @minimum 1
    expired_in Int? @db.Integer

    /// Expiration date.
    /// 
    /// A concept that expires after YYYY-MM-DD after a discount coupon ticket 
    /// is issued.
    /// 
    /// Double restrictions are possible with `expired_in`, of which the one 
    /// with the shorter expiration date is used.
    expired_at DateTime? @db.Timestamptz

    /// Issuance starting date.
    opened_at DateTime? @db.Timestamptz

    /// Issuance end date.
    /// 
    /// Tickets cannot be issued after this time.
    /// 
    /// However, previously issued tickets can still be used until their 
    /// expiration date.
    closed_at DateTime? @db.Timestamptz

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Update time of record.
    ///
    /// Only possible to update until `opened_at`.
    updated_at DateTime @db.Timestamptz

    /// Deletion time of record.
    ///
    /// Pre-issued tickets can still be used until their expiration date.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Administrator who created this coupon.
    administrator shopping_administrators? @relation(fields: [shopping_administrator_id], references: [id], onDelete: Cascade)

    /// Seller who created this coupon.
    seller shopping_sellers? @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)

    /// List of criterias.
    criterias shopping_coupon_criterias[]

    /// List of one-time issuance codes.
    ///
    /// If the `accessor` value of this discount coupon is private, a dedicated 
    /// code is required to issue a ticket for the discount coupon. A list of 
    /// those one-time use codes. 
    disposables shopping_coupon_disposables[]

    /// List of tickets.
    ///
    /// Histories of tickets issued to customers.
    tickets shopping_coupon_tickets[]

    @@index([shopping_administrator_id])
    @@index([shopping_seller_id])
}

/// Supertype for the applicable conditions of the discount coupon.
/// 
/// `shopping_coupon_criterias` is a supertype entity that embodies the 
/// conditions for applying a {@link shopping_coupons discount coupon}. All 
/// subtype entities that wish to impose constraints on the reference unit of 
/// a discount coupon were created by inheriting this. For example, the 
/// {@link shopping_coupon_section_criterias} entity, designed to limit 
/// application to a specific {@link shopping_sections section}, inherits this 
/// entity `shopping_coupon_criterias`.
/// 
/// In addition, constraints on reference units can be specified through the 
/// `direction` property to proceed as an inclusion condition or, conversely, 
/// as an exclusion condition. If the direction value is "include", the coupon 
/// is applicable only to the reference object. Conversely, if the direction 
/// value is "exclude", it is a coupon that cannot be applied to the reference 
/// object.
/// 
/// @namespace Coupons
/// @author Samchon
model shopping_coupon_criterias {
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged coupon's {@link shopping_coupons.id}
    ///
    /// @format uuid
    shopping_coupon_id String @db.Uuid

    /// Type of criteria.
    ///
    /// It means which subtype being used.
    type String @db.VarChar

    /// Direction of criteria.
    ///
    /// - include
    /// - exclude
    direction String @db.VarChar

    /// Sequence order in belonged coupon.
    ///
    /// @format int
    sequence Int @db.Integer

    //----
    // RELATIONS
    //----
    /// Belonged coupon.
    coupon shopping_coupons @relation(fields: [shopping_coupon_id], references: [id], onDelete: Cascade)

    of_section shopping_coupon_section_criterias?
    of_channel shopping_coupon_channel_criterias?
    of_sale    shopping_coupon_sale_criterias?
    of_funnel  shopping_coupon_funnel_criterias?
    of_seller  shopping_coupon_seller_criterias?

    @@index([shopping_coupon_id])
}

/// Conditions for sections of discount coupons.
/// 
/// `shopping_coupon_section_criterias` is a subtype entity of 
/// {@link shopping_coupon_criterias} and is used when setting conditions for 
/// a specific {@link shopping_sections section}.
/// 
/// If the {@link shopping_coupon_criterias.direction} value is "include", 
/// the coupon can only be used for that section. Conversely, if it is 
/// "exclude", the coupon cannot be used. And if there are multiple 
/// `shopping_coupon_section_criterias` records within one coupon, conditions 
/// are applied on a bundle basis. Coupons may or may not be applicable to 
/// eligible sections.
/// 
/// @namespace Coupons
/// @author Samchon
model shopping_coupon_section_criterias {
    /// @format uuid
    id String @id @db.Uuid

    /// Target section's {@link shopping_coupon_criterias.id}
    ///
    /// @format uuid
    shopping_section_id String @db.Uuid

    //----
    // RELATIONS
    //----
    /// Supertype entity.
    base shopping_coupon_criterias @relation(fields: [id], references: [id], onDelete: Cascade)

    /// Belonged section.
    section shopping_sections @relation(fields: [shopping_section_id], references: [id], onDelete: Cascade)

    @@index([shopping_section_id])
}

/// Conditions for channels of discount coupons.
/// 
/// `shopping_coupon_channel_criterias` is a subtype entity of 
/// {@link shopping_coupon_criterias} and is used when setting conditions on 
/// a specific {@link shopping_channels channel} or 
/// {@link shopping_channel_categories category} of that channel.
/// 
/// If the {@link shopping_coupon_criterias.direction} value is "include", 
/// the coupon can only be used for that channel (or category). Conversely, 
/// if it is "exclude", it is a coupon that cannot be used. And if there are 
/// multiple `shopping_coupon_channel_criterias` records within one coupon, 
/// conditions are applied on a bundle basis. Coupons may or may not be 
/// applicable for target channels and categories.
/// 
/// @namespace Coupons
/// @author Samchon
model shopping_coupon_channel_criterias {
    /// @format uuid
    id String @id @db.Uuid

    /// Target channel's {@link shopping_channels.id}
    ///
    /// @format uuid
    shopping_channel_id String @db.Uuid

    /// Target channel category's {@link shopping_channel_categories.id}
    ///
    /// @format uuid
    shopping_channel_category_id String? @db.Uuid

    //----
    // RELATIONS
    //----
    /// Supertype entity.
    base shopping_coupon_criterias @relation(fields: [id], references: [id], onDelete: Cascade)

    /// Target channel.
    channel shopping_channels @relation(map: "rel_shopping_coupon_channel_criterias_channel", fields: [shopping_channel_id], references: [id], onDelete: Cascade)

    /// Target channel category.
    category shopping_channel_categories? @relation(map: "rel_shopping_coupon_channel_criterias_category", fields: [shopping_channel_category_id], references: [id], onDelete: Cascade)

    @@index([shopping_channel_id])
    @@index([shopping_channel_category_id])
}

/// Conditions for sellers of discount coupons.
/// 
/// `shopping_coupon_seller_criterias` is a subtype entity of 
/// {@link shopping_coupon_criterias} and is used when setting conditions for 
/// a specific {@link shopping_sellers seller}.
/// 
/// If the {@link shopping_coupon_criterias.direction} value is "include", the 
/// coupon can only be used for that seller. Conversely, if it is "exclude", 
/// the coupon cannot be used.
/// 
/// And if there are multiple `shopping_coupon_seller_criterias` records within 
/// one coupon, conditions are applied on a bundle basis. Coupons may or may 
/// not be applicable to eligible sellers.
/// 
/// @namespace Coupons
/// @author Samchon
model shopping_coupon_seller_criterias {
    /// PK + FK.
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// Target seller's {@link shopping_sellers.id}
    ///
    /// @format uuid
    shopping_seller_id String @db.Uuid

    //----
    // RELATIONS
    //----
    /// Supertype entity.
    base shopping_coupon_criterias @relation(fields: [id], references: [id], onDelete: Cascade)

    /// Target seller.
    seller shopping_sellers @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)

    @@index([shopping_seller_id])
}

/// Conditions for a specific item in a discount coupon.
/// 
/// `shopping_coupon_sale_criterias` is a subtype entity of 
/// {@link shopping_coupon_criterias} and is used when setting conditions for 
/// a specific {@link shopping_sales sale}.
/// 
/// If the {@link shopping_coupon_criterias.direction} value is "include", 
/// the coupon can only be used for that item. Conversely, if it is "exclude", 
/// it is a coupon that cannot be used.
/// 
/// And if there are multiple shopping_coupon_sale_criterias records within one coupon, conditions are applied on a bundle basis. Coupons that may or may not be applicable to target properties.
///
/// @namespace Coupons
/// @author Samchon
model shopping_coupon_sale_criterias {
    /// PK + FK.
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// Target sale's {@link shopping_sales.id}
    ///
    /// @format uuid
    shopping_sale_id String @db.Uuid

    //----
    // RELATIONS
    //----
    /// Supertype entity.
    base shopping_coupon_criterias @relation(fields: [id], references: [id], onDelete: Cascade)

    /// Target sale.
    sale shopping_sales @relation(fields: [shopping_sale_id], references: [id], onDelete: Cascade)

    @@index([shopping_sale_id])
}

/// Limit the funnel of discount coupons.
/// 
/// `shopping_coupon_funnel_criterias` is a subtype entity of 
/// {@link shopping_coupon_criterias}, and is used when you want to issue or 
/// exclude discount coupons only to {@link shopping_customers customers} who 
/// came from a specific path.
/// 
/// And funnel restrictions are possible in 3 ways: The first is 
/// {@link shopping_customers.referrer}, and by parsing 
/// {@link shopping_customers.href}, which records the customer's access 
/// address, restrictions can be made in units of specific URLs or variables.
/// 
/// @namespace Coupons
/// @author Samchon
model shopping_coupon_funnel_criterias {
    /// PK + FK.
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// What kind of funnel is it?
    ///
    /// - path
    /// - referrer
    /// - variable
    kind String @db.VarChar

    /// Key name of funnel, when `kind` is "variable".
    key String? @db.VarChar

    /// Value of funnel.
    value String @db.VarChar

    //----
    // RELATIONS
    //----
    /// Supertype entity.
    base shopping_coupon_criterias @relation(fields: [id], references: [id], onDelete: Cascade)
}

/// Discount coupon ticket issuance details.
/// 
/// `shopping_coupon_tickets` is an entity that symbolizes 
/// {@link shopping_coupons discount coupon} tickets issued by customers.
/// 
/// And if the target discount coupon specification itself has an expiration 
/// date, the expiration date is recorded in `expired_at` and is automatically 
/// discarded after that expiration date. Of course, it doesn't matter if you 
/// use the discount coupon for your order within the deadline.
/// 
/// @namespace Coupons
/// @author Samchon
model shopping_coupon_tickets {
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged customer's {@link shopping_customers.id}
    ///
    /// @format uuid
    shopping_customer_id String @db.Uuid

    /// Belonged coupon's {@link shopping_coupons.id}
    ///
    /// @format uuid
    shopping_coupon_id String @db.Uuid

    /// Belonged disposable's {@link shopping_coupon_disposables.id}
    ///
    /// Only when current ticket be issued from one-time code.
    ///
    /// @format uuid
    shopping_coupon_disposable_id String? @db.Uuid

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Expiration time of ticket.
    expired_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged customer.
    customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)

    /// Belonged coupon.
    coupon shopping_coupons @relation(fields: [shopping_coupon_id], references: [id], onDelete: Cascade)

    /// Belonged disposable when issued from one-time code.
    disposable shopping_coupon_disposables? @relation(fields: [shopping_coupon_disposable_id], references: [id], onDelete: Cascade)

    /// Payment information.
    payment shopping_coupon_ticket_payments?

    @@unique([shopping_coupon_disposable_id])
    @@index([shopping_customer_id])
    @@index([shopping_coupon_id])
    @@index([shopping_coupon_disposable_id])
}

/// Discount coupon ticket payment details.
/// 
/// `shopping_coupon_ticket_payments` is an entity that embodies the payment 
/// information for the {@link shoppiing_orders order} of  
/// {@link shopping_coupon_tickets}, and is used when a consumer uses the 
/// discount coupon ticket he or she was issued to order and has the payment 
/// amount deducted.
/// 
/// And since {@link shopping_orders} itself is not an entity used in situations 
/// where an order is completed, but rather an entity designed to express an 
/// order request, the creation of this `shopping_coupon_ticket_payments` record 
/// does not actually mean that the attached ticket disappears. Until the 
/// customer completes the payment and confirms the order, the ticket can be 
/// understood as a kind of deposit.
/// 
/// Additionally, this record can be deleted by the customer reversing the 
/// payment of the ticket, but it can also be deleted when the attribution 
/// order itself is canceled.
/// 
/// @namespace Coupons
/// @author Samchon
model shopping_coupon_ticket_payments {
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged ticket's {@link shopping_coupon_tickets.id}
    ///
    /// @format uuid
    shopping_coupon_ticket_id String @db.Uuid

    /// Target order's {@link shopping_orders.id}
    ///
    /// @format uuid
    shopping_order_id String @db.Uuid

    /// Sequence order(?) in belonged order.
    ///
    /// @format int
    sequence Int @db.Integer

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Deletion time of record.
    ///
    /// In other words, it means that the target order be erased or payment 
    /// be cancelled.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged ticket.
    ticket shopping_coupon_tickets @relation(fields: [shopping_coupon_ticket_id], references: [id], onDelete: Cascade)

    /// Target order.
    order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)

    @@unique([shopping_coupon_ticket_id])
    @@index([shopping_order_id])
}

/// Discount coupon issuance code management.
/// 
/// If a {@link shopping_coupons discount coupon} is not public and anyone can 
/// receive the ticket, but can only be received by entering a specific 
/// password (one-time code), use this `shopping_coupon_disposables` entity.
/// 
/// I repeat again, the code code is "one-time use". In other words, if any of 
/// the customers enters the code, the code is discarded when the ticket 
/// issuance to the customer is completed. Therefore, if you want to issue 
/// tickets multiple times using a discount coupon as a secret code, the 
/// issuing code must also be supported by the corresponding quantity.
/// 
/// @namespace Coupons
/// @author Samchon
model shopping_coupon_disposables {
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged coupon's {@link shopping_coupons.id}
    ///
    /// @format uuid
    shopping_coupon_id String @db.Uuid

    /// Identifier code.
    ///
    /// Another word, one-time password for issuance.
    code String @db.VarChar

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Expired time of record.
    expired_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// Belonged discount coupon.
    coupon shopping_coupons @relation(fields: [shopping_coupon_id], references: [id], onDelete: Cascade)

    /// Ticket issued by this one-time code.
    ticket shopping_coupon_tickets?

    @@unique([code])
    @@index([shopping_coupon_id])
}

//-----------------------------------------------------------
// COINS
//-----------------------------------------------------------
/// Meta information of the deposit.
/// 
/// `shopping_deposits` is an entity that embodies the specifications for 
/// incomes and outcomes at a shopping mall. In other words, 
/// `shopping_deposits` is not {@link shopping_deposit_histories}, which 
/// refers to the deposit/outcome details of deposits, but is simply 
/// metadata that specifies specifications for income/outcome scenarios.
///
/// @namespace Coins
/// @author Samchon
model shopping_deposits {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Identifier code.
    code String @db.VarChar

    /// The source table occuring the deposit event.
    source String @db.VarChar

    /// Direction of deposit.
    ///
    /// - `1`: Income
    /// - `-1`: outcome
    direction Int @db.Integer

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    //// Deletion time of record.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    /// List of histories; income/outcome details.
    histories shopping_deposit_histories[]

    @@unique([code])
    @@index([source])
}

/// Deposit income/outcome details of customers (citizens).
///
/// `shopping_deposit_histories` is an entity that embodies the 
/// {@link shopping_customers customer}'s income/outcome history.
///
/// You can think of it as a kind of accounting ledger table. Therefore, 
/// note that, `value` must have positive number only, even if it is a 
/// outcome. The minus value must be expressed by multiplying the 
/// {@link shopping_deposits.direction} value of the corresponding.
///
/// @namespace Coins
/// @author Samchon
model shopping_deposit_histories {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged metadata's {@link shopping_deposits.id}
    ///
    /// @format uuid
    shopping_deposit_id String @db.Uuid

    /// Belonged citizen's {@link shopping_citizens.id}
    ///
    /// @format uuid
    shopping_citizen_id String @db.Uuid

    /// The source record occured deposit/outcome. 
    ///
    /// @format uuid
    source_id String @db.Uuid

    /// Income/outcome amount of deposit.
    /// 
    /// It must be a positive number, and you can check 
    /// {@link shopping_deposits.direction} for incomes and outcomes. 
    /// If you want to express the figures for incomes and outcomes as 
    /// positive/negative numbers, you can also multiply this field value by 
    /// the attributed {@link shopping_deposits.direction} value.
    ///
    /// @minimum 0
    value Float @db.DoublePrecision

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Cancelled time of record.
    cancelled_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    deposit shopping_deposits @relation(fields: [shopping_deposit_id], references: [id])
    citizen shopping_citizens @relation(fields: [shopping_citizen_id], references: [id])
}

/// Deposit deposit.
/// 
/// `shopping_deposit_charges` is an entity that symbolizes the act of a 
/// {@link shopping_customers customer} applying for a deposit to a shopping 
/// mall.
/// 
/// However, `shopping_deposit_charges` expresses the customer's intention to 
/// make a deposit, but it has not yet been confirmed. Only when the customer 
/// completes the {@link shopping_deposit_charge_publishes.paid_at payment} 
/// will the deposit increase be confirmed.
/// 
/// @namespace Coins
/// @author Samchon
model shopping_deposit_charges {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged metadata's {@link shopping_deposits.id}
    ///
    /// @format uuid
    shopping_customer_id String @db.Uuid

    /// Charging amount.
    ///
    /// @exclusiveMinimum 0
    amount Float @db.DoublePrecision

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Deletion time of record.
    ///
    /// Only when be stopped before publishing.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    customer shopping_customers                 @relation(fields: [shopping_customer_id], references: [id])
    publish  shopping_deposit_charge_publishes?
}

/// Payment progress information for deposits.
/// 
/// `shopping_deposit_charge_publishes` is an entity that embodies the process 
/// of a {@link shopping_customers customer} applying for a deposit and making 
/// a payment.
/// 
/// Please note that the existence of the `shopping_deposit_charge_publishes` 
/// record does not mean that payment has been completed. Payment is complete 
/// only when payment (`paid_at`) is complete. This is what the 
/// "process of payment" mentioned above means.
/// 
/// However, even after payment has been made, there may be cases where it is 
/// suddenly canceled, so you must be careful about this as well.
/// 
/// @namespace Coins
/// @author Samchon
model shopping_deposit_charge_publishes {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged charge appliance's {@link shopping_deposit_charges.id}
    ///
    /// @format uuid
    shopping_deposit_charge_id String @db.Uuid

    /// Password for encryption.
    /// 
    /// This shopping mall system uses a randomly issued password to encrypt 
    /// payment history, and is completely unrelated to the user.
    password String? @db.VarChar

    /// Creation time of record.
    ///
    /// Note that, this property does not mean the payment completion time.
    created_at DateTime @db.Timestamptz

    /// Completion time of payment.
    /// 
    /// This property is the only way to know if the payment has been 
    /// completed. If this property is null, the payment has not been 
    /// completed yet.
    paid_at DateTime? @db.Timestamptz

    /// The time when the payment was cancelled or reverted.
    cancelled_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    charge shopping_deposit_charges @relation(fields: [shopping_deposit_charge_id], references: [id])

    @@unique([shopping_deposit_charge_id])
}

/// Meta information of mileage.
/// 
/// `shopping_mileages` is an entity that embodies specifications for mileage 
/// deposits and outcomes at a shopping mall. In other words, 
/// `shopping_mileages` is not {@link shopping_mileage_histories}, which means 
/// mileage deposit and outcome history, but is simply metadata that 
/// specifies specifications for scenarios in which mileage is deposited and 
/// withdrawn.
///
/// @namespace Coins
/// @author Samchon
model shopping_mileages {
    /// @format uuid
    id String @id @db.Uuid

    /// Identifier code.
    code String @db.VarChar

    /// The source table occuring the mileage event.
    source String @db.VarChar

    /// Direction of mileage.
    ///
    /// - `1`: Income
    /// - `-1`: outcome
    direction Int @db.Integer

    /// Default value of mileage.
    ///
    /// Possible to mit, and how to use this default value is up to the
    /// backend program. It is okay to use it as a default value when
    /// creating a new record, or percentage value to be applied.
    ///
    /// @minimum 0
    default Float? @db.DoublePrecision

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Deletion time of record.
    deleted_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    histories shopping_mileage_histories[]

    @@unique([code])
}

/// Mileagea income/outcome details of customers (citizens).
///
/// `shopping_mileage_histories` is an entity that embodies the 
/// {@link shopping_customers customer}'s deposit/outcome history.
///
/// You can think of it as a kind of accounting ledger table. Therefore, 
/// note that, `value` must have positive number only, even if it is a 
/// outcome. The minus value must be expressed by multiplying the 
/// {@link shopping_mileages.direction} value of the corresponding.
///
/// @namespace Coins
/// @author Samchon
model shopping_mileage_histories {
    //----
    // COLUMNS
    //----
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged metadata's {@link shopping_mileages.id}
    ///
    /// @format uuid
    shopping_mileage_id String @db.Uuid

    /// Belonged citizen's {@link shopping_citizens.id}
    ///
    /// @format uuid
    shopping_citizen_id String @db.Uuid

    /// The source record occured income/outcome. 
    ///
    /// @format uuid
    source_id String @db.Uuid

    /// Income/outcome amount of mileage.
    /// 
    /// It must be a positive number, and you can check 
    /// {@link shopping_mileages.direction} for incomes and outcomes. 
    /// If you want to express the figures for incomes and outcomes as 
    /// positive/negative numbers, you can also multiply this field value by 
    /// the attributed {@link shopping_mileages.direction} value.
    ///
    /// @minimum 0
    value Float @db.DoublePrecision

    /// Creation time of record.
    created_at DateTime @db.Timestamptz

    /// Cancelled time of record.
    cancelled_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    mileage shopping_mileages @relation(fields: [shopping_mileage_id], references: [id])
    citizen shopping_citizens @relation(fields: [shopping_citizen_id], references: [id])
}

//-----------------------------------------------------------
// INQUIRIES
//-----------------------------------------------------------
/// Inquiry about a sale snapshot.
/// 
/// `shopping_sale_snapshot_inquiries` is a subtype entity of 
/// {@link bbs_articles}, and represents inquiries written by 
/// {@link shopping_customers customers} about a {@link shopping_sales sale} 
/// registered by the {@link shopping_sellers seller} (however, to trace the
/// exact {@link shopping_sale_snapshots snapshot}, it is referencing not
/// sale but snapshot).
/// 
/// In addition, since the customer is waiting for the seller's response after 
/// writing the inquiry, whether the seller has viewed the inquiry written by 
/// the customer is provided for reference as `read_by_seller_at` at property. 
/// Of course, since the inquery itself is a subtype of a article, it is also 
/// possible for sellers to communicate with each other through 
/// {@link shopping_sale_snapshot_inquiry_comments comments} before an 
/// {@link shopping_sale_snapshot_inquiry_responses official response}.
/// 
/// However, comments themselves can only be made by customers, even if they 
/// are not the person who wrote the article. Of course, it cannot be written 
/// unless the seller is a party.
///
/// @namespace Inquiries
/// @author Samchon
model shopping_sale_snapshot_inquiries {
    //----
    // COLUMNS
    //----
    /// PK + FK.
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged snapshot's {@link shopping_sale_snapshots.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_id String @db.Uuid

    /// Writer customer's {@link shopping_customers.id}
    ///
    /// @format uuid
    shopping_customer_id String @db.Uuid

    /// Type of the inquiry article.
    ///
    /// - `question`
    /// - `review`
    type String @db.VarChar

    /// The first time when the seller read the inquiry.
    read_by_seller_at DateTime? @db.Timestamptz

    //----
    // RELATIONS
    //----
    base     bbs_articles            @relation(fields: [id], references: [id], onDelete: Cascade)
    snapshot shopping_sale_snapshots @relation(fields: [shopping_sale_snapshot_id], references: [id], onDelete: Cascade)
    customer shopping_customers      @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)

    of_question                            shopping_sale_snapshot_questions?
    of_review                              shopping_sale_snapshot_reviews?
    shopping_sale_snapshot_inquiry_answers shopping_sale_snapshot_inquiry_answers[]
}

/// Question about sale snapshot.
/// 
/// `shopping_sale_snapshot_questions` is a subtype entity of 
/// {@link shopping_sale_snapshot_inquiries}, and is used when a 
/// {@link shopping_customers customer} wants to ask something about a 
/// sale ({@link shopping_sale_snapshots snapshot} at the time) registered by 
/// the {@link shopping_sellers seller}.
/// 
/// And, like most shopping malls, `shopping_sale_snapshot_questions` also 
/// provides a `secret` attribute, allowing you to create a "secret message" 
/// that can only be viewed by the seller and the customer who wrote the 
/// question.
///
/// @namespace Inquiries
/// @author Samchon
model shopping_sale_snapshot_questions {
    //----
    // COLUMNS
    //----
    /// PK + FK.
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// Whether secret or not.
    secret Boolean @db.Boolean

    //----
    // RELATIONS
    //----
    base shopping_sale_snapshot_inquiries @relation(fields: [id], references: [id], onDelete: Cascade)
}

/// Reviews for sale snapshots.
/// 
/// `shopping_sale_snapshot_reviews` is a subtype entity of 
/// {@link shopping_sale_snapshot_inquiries}, and is used when a 
/// {@link shopping_customers customer} purchases a sale 
/// ({@link shopping_sale_snapshots snapshot} at the time) registered by the 
/// {@link shopping_sellers seller} as a product and leaves a review and 
/// rating for it.
/// 
/// For reference, `shopping_sale_snapshot_reviews` and 
/// {@link shopping_order_goods} have a logarithmic relationship of N: 1, 
/// but this does not mean that customers can continue to write reviews for 
/// the same product indefinitely. Wouldn't there be restrictions, such as 
/// if you write a review once, you can write an additional review a month 
/// later?
///
/// @namespace Inquiries
/// @author Samchon
model shopping_sale_snapshot_reviews {
    //----
    // COLUMNS
    //----
    /// PK + FK.
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged good's {@link shopping_order_goods.id}
    ///
    /// @format uuid
    shopping_order_good_id String @db.Uuid

    //----
    // RELATIONS
    //----
    base shopping_sale_snapshot_inquiries @relation(fields: [id], references: [id], onDelete: Cascade)
    good shopping_order_goods             @relation(fields: [shopping_order_good_id], references: [id], onDelete: Cascade)

    @@index([shopping_order_good_id])
}

/// A snapshot of the content of the review for the sale snapshot.
/// 
/// `shopping_sale_snapshot_review_snapshots` is a subtype entity of 
/// {@link bbs_article_snapshots} and is designed to add a `score` property 
/// to the content of {@link shopping_sale_snapshot_reviews review article).
/// 
/// In other words, after writing a review article, customers can edit it 
/// and change the evaluation `score` at any time.
///
/// @namespace Inquiries
/// @author Samchon
model shopping_sale_snapshot_review_snapshots {
    //----
    // COLUMNS
    //----
    /// PK + FK.
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// Estimation score value.
    ///
    /// @minimum 0
    /// @maximum 100
    score Float @db.DoublePrecision

    //----
    // RELATIONS
    //----
    base bbs_article_snapshots @relation(fields: [id], references: [id], onDelete: Cascade)
}

/// Answers to questions about sale snapshots.
/// 
/// `shopping_sale_snapshot_inquiry_answers` is an entity that embodies the 
/// official answer written by the {@link shopping_sellers seller} to the 
/// {@link shopping_sale_snapshot_inquiries inquiry} written by the 
/// {@link shopping_customers customer}.
/// 
/// Of course, in addition to writing an official response like this, it is 
/// also possible for the seller to communicate with the questioner and 
/// multiple customers through 
/// {@link shopping_sale_snapshot_inquiry_comments comments} in the 
/// attribution inquiry.
/// 
/// For refererence, it is not possible to write comments on this answer. 
/// Encourage people to write comments on the inquiry article. This is to 
/// prevent comments from being scattered in both inquiry and response 
/// articles.
///
/// @namespace Inquiries
/// @author Samchon
model shopping_sale_snapshot_inquiry_answers {
    //----
    // COLUMNS
    //----
    /// PK + FK
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// Belonged inquiry's {@link shopping_sale_snapshot_inquiries.id}
    ///
    /// @format uuid
    shopping_sale_snapshot_inquiry_id String @db.Uuid

    /// Answered seller's {@link shopping_sellers.id}
    ///
    /// @format uuid
    shopping_seller_id String @db.Uuid

    //----
    // RELATIONS
    //----
    base    bbs_articles                     @relation(fields: [id], references: [id], onDelete: Cascade)
    inquiry shopping_sale_snapshot_inquiries @relation(fields: [shopping_sale_snapshot_inquiry_id], references: [id], onDelete: Cascade)
    seller  shopping_sellers                 @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)
}

/// A comment written on a question post.
/// 
/// `shopping_sale_snapshot_inquiry_comments` is a subtype entity of 
/// {@link bbs_article_comments), and is used when you want to communicate with 
/// multiple people about an {@link shopping_sale_snapshot_inquiries inquiry} 
/// written by a {@link shopping_customers customer}.
/// 
/// For reference, only related parties can write comments for 
/// {@link shopping_sellers sellers}, but there is no limit to customers. 
/// In other words, anyone can freely write a comment, even if they are not 
/// the person who wrote the inquiry.
///
/// @namespace Inquiries
/// @author Samchon
model shopping_sale_snapshot_inquiry_comments {
    //----
    // COLUMNS
    //----
    /// PK + FK
    ///
    /// @format uuid
    id String @id @db.Uuid

    /// Writer seller's {@link shopping_sellers.id}
    ///
    /// @format uuid
    shopping_seller_id String? @db.Uuid

    /// Writer customer's {@link shopping_customers.id}
    ///
    /// @format uuid
    shopping_customer_id String? @db.Uuid

    //----
    // RELATIONS
    //----
    base     bbs_article_comments @relation(fields: [id], references: [id], onDelete: Cascade)
    seller   shopping_sellers?    @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)
    customer shopping_customers?  @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)
}
